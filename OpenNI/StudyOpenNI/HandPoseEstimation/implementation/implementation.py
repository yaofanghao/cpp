#coding=utf-8import matplotlib.pyplot as pltimport matplotlib.image as mpimgimport numpy as npimport cv2import mathimport caffeimport mpl_toolkits.mplot3dfrom mpl_toolkits.mplot3d import Axes3Ddeploy = "deploy.prototxt"caffe_model = "FinalNoRandom.caffemodel"caffe_model = "FinalRandomNoise.caffemodel"# caffe_model = "FinalRandom.caffemodel"i = 0imgPath = './img/'img = cv2.imread(imgPath+'color_{}.png'.format(i))# get the position of the palmhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)params = cv2.SimpleBlobDetector_Params()# Filter by Area.params.filterByArea = Trueparams.minArea = 10params.filterByColor = Trueparams.blobColor = 0# Filter by Convexityparams.filterByConvexity = Trueparams.minConvexity = 0.6# Filter by Circularityparams.filterByCircularity = Trueparams.minCircularity = 0lower_green = np.array([40, 60, 60])upper_green = np.array([100, 360, 360])mask = cv2.inRange(hsv, lower_green, upper_green)msk1 = np.bitwise_and(mask == 0, True)img[msk1] = 255img[~msk1] = 0detector = cv2.SimpleBlobDetector(params)keypoints = detector.detect(img)u = (int)(keypoints[0].pt[0])v = (int)(keypoints[0].pt[1])cube_size = 350img_size = 128fx = 575.0fy = 575.0fu = 320.fv = 240.def CropImage(depth, com):  # u v d info of palm  u, v, d = com  # z is equal to d  zstart = d - cube_size/2  zend = d + cube_size/2  hsv = cv2.cvtColor(colorImg, cv2.COLOR_BGR2HSV)  lower_blue = np.array([50, 0, 0])  upper_blue = np.array([150, 360, 360])  mask = cv2.inRange(hsv, lower_blue, upper_blue)  msk1 = np.bitwise_and(mask == 0, True)  depth[~msk1] = zend  # transform xyz domain to uvz domain  xstart = int(math.floor((u * d / fx - cube_size / 2.) / d * fx))  xend = int(math.floor((u * d / fx + cube_size / 2.) / d * fx))  ystart = int(math.floor((v * d / fy - cube_size / 2.) / d * fy))  yend = int(math.floor((v * d / fy + cube_size / 2.) / d * fy))  # select the cropped domain, if box is beyond the boundary just pad it  cropped = depth[max(ystart, 0):min(yend, depth.shape[0]), max(xstart, 0):min(xend, depth.shape[1])].copy()  cropped = np.pad(cropped, ((abs(ystart)-max(ystart, 0), abs(yend)-min(yend, depth.shape[0])),                                (abs(xstart)-max(xstart, 0), abs(xend)-min(xend, depth.shape[1]))), mode='constant', constant_values=0)  width = cropped.shape[0]  height = cropped.shape[1]  for i in range(width):    for j in range(height):      if(cropped[i][j] == 0):        cropped[i][j] = zend      if(cropped[i][j] < zstart):        cropped[i][j] = zstart      if(cropped[i][j] > zend):        cropped[i][j] = zend  dsize = (img_size, img_size)  wb = (xend - xstart)  hb = (yend - ystart)  # transform 150*150 to 128*128  if wb > hb:    sz = (dsize[0], hb * dsize[0] / wb)  else:    sz = (wb * dsize[1] / hb, dsize[1])  roi = cropped  rz = cv2.resize(cropped, dsize)  ret = np.ones(dsize, np.float32) * zend  # ret = np.ones(dsize, np.float32)  xstart = int(math.floor(dsize[0] / 2 - rz.shape[1] / 2))  xend = int(xstart + rz.shape[1])  ystart = int(math.floor(dsize[1] / 2 - rz.shape[0] / 2))  yend = int(ystart + rz.shape[0])  ret[ystart:yend, xstart:xend] = rz  return retimgDepth = cv2.imread(imgPath+'depth_{}.png'.format(i), -1)colorImg = cv2.imread(imgPath+'color_{}.png'.format(i))depth = np.asarray(imgDepth[:, :])depthOrg = depth.copy()# net creationnet = caffe.Net(deploy, caffe_model, caffe.TEST)transformer = caffe.io.Transformer({'data': net.blobs['data'].data.shape})  # 设定图片的shape格式(1,1,128,128)# print depth.shape# print d/10000.0*10d = depthOrg[v, u] + 40# depth = CropImage(depthOrg, [u,v,d], cube_size)depth = CropImage(depthOrg, [u,v,d])depth = ((depth - d) / (cube_size/2.0)).reshape(img_size, img_size)net.blobs['data'].data[...] = transformer.preprocess('data', depth)  # 执行上面设置的图片预处理操作，并将图片载入到blob中# 执行测试out = net.forward()img = CropImage(depthOrg, [u,v,d]) - 1200 #to show the handjoint = net.blobs['DeepHandModelxyz'].data[0].flatten()  # 取出最后一层（Softmax）属于某个类别的概率值，并打印J = 14joints = np.arange(14)x = np.zeros(J)y = np.zeros(J)z = np.zeros(J)for j in range(J):    x[j] = joint[joints[j] * 3]    y[j] = joint[joints[j] * 3 + 1]    z[j] = joint[joints[j] * 3 + 2]    cv2.circle(img, (int((x[j] + 1) / 2 * 128), int((- y[j] + 1) / 2 * 128)), 3, (1,1,1),thickness=-1)cv2.circle(img, (64, 64), 3, (1,1,1), thickness=-1)# connect line between different joints# line 0-3cv2.line(img,(int((x[0] + 1) / 2 * 128), int((- y[0] + 1) / 2 * 128)),(int((x[1] + 1) / 2 * 128), int((- y[1] + 1) / 2 * 128)), (0.4,0,0.4),1,1,0)# line 6-9cv2.line(img,(int((x[2] + 1) / 2 * 128), int((- y[2] + 1) / 2 * 128)),(int((x[3] + 1) / 2 * 128), int((- y[3] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)# line 12-15cv2.line(img,(int((x[4] + 1) / 2 * 128), int((- y[4] + 1) / 2 * 128)),(int((x[5] + 1) / 2 * 128), int((- y[5] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)# line 18-21cv2.line(img,(int((x[6] + 1) / 2 * 128), int((- y[6] + 1) / 2 * 128)),(int((x[7] + 1) / 2 * 128), int((- y[7] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)# line 24-25cv2.line(img,(int((x[8] + 1) / 2 * 128), int((- y[8] + 1) / 2 * 128)),(int((x[9] + 1) / 2 * 128), int((- y[9] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[1] + 1) / 2 * 128), int((- y[1] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[3] + 1) / 2 * 128), int((- y[3] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[5] + 1) / 2 * 128), int((- y[5] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[7] + 1) / 2 * 128), int((- y[7] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[11] + 1) / 2 * 128), int((- y[11] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[12] + 1) / 2 * 128), int((- y[12] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)cv2.line(img,(int((x[10] + 1) / 2 * 128), int((- y[10] + 1) / 2 * 128)),(int((x[9] + 1) / 2 * 128), int((- y[9] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)cv2.line(img,(int((x[10] + 1) / 2 * 128), int((- y[10] + 1) / 2 * 128)),(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)plt.figure()# plt.imshow(img, cmap='gray')plt.imshow(img)plt.hold('on')fig = plt.figure()ax = fig.add_subplot((111), projection='3d')ax.set_xlabel('z')ax.set_ylabel('x')ax.set_zlabel('y')ax.scatter(z, -x, y)joint_id = np.array([0, 3, 6, 9, 12, 15, 18, 21, 24, 25, 27, 30, 31, 32])# Edges = [[0, 1], [2, 3],[4, 5],[6, 7],[8, 9],[1,13],[3,13],[5,13],[7,13],[9,10],[10,13]]Edges = [[0, 1], [2, 3],[4, 5],[6, 7],[8, 9],[1,13],[3,13],[5,13],[7,13],[9,10],[10,13],[11,13],[12,13]]for e in Edges:  ax.plot(z[e], -x[e], y[e], c='b')plt.show()