#coding=utf-8import matplotlib.pyplot as pltimport matplotlib.image as mpimgimport numpy as npimport cv2import mathimport caffeimport mpl_toolkits.mplot3dfrom mpl_toolkits.mplot3d import Axes3D# this file show the object separation in depth imagei = 0imgPath = './img/'img = cv2.imread(imgPath+'color_{}.png'.format(i))# get the position of the palmhsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)params = cv2.SimpleBlobDetector_Params()# Filter by Area.params.filterByArea = Trueparams.minArea = 10params.filterByColor = Trueparams.blobColor = 0# Filter by Convexityparams.filterByConvexity = Trueparams.minConvexity = 0.8# Filter by Circularityparams.filterByCircularity = Trueparams.minCircularity = 0lower_green = np.array([40, 60, 60])upper_green = np.array([100, 360, 360])mask = cv2.inRange(hsv, lower_green, upper_green)msk1 = np.bitwise_and(mask == 0, True)img[msk1] = 255img[~msk1] = 0detector = cv2.SimpleBlobDetector(params)keypoints = detector.detect(img)u = (int)(keypoints[0].pt[0])v = (int)(keypoints[0].pt[1])cube_size = 350img_size = 128fx = 575.0   #525fy = 575.0fu = 320.fv = 240.def CropImage(depth, com):  # u v d info of palm  u, v, d = com  # z is equal to d  zstart = d - cube_size/2  zend = d + cube_size/2  hsv = cv2.cvtColor(colorImg, cv2.COLOR_BGR2HSV)  lower_blue = np.array([100, 0, 0])  upper_blue = np.array([150, 360, 360])  mask = cv2.inRange(hsv, lower_blue, upper_blue)  msk1 = np.bitwise_and(mask == 0, True)  depth[~msk1] = zend  # transform xyz domain to uvz domain  xstart = int(math.floor((u * d / fx - cube_size / 2.) / d * fx))  xend = int(math.floor((u * d / fx + cube_size / 2.) / d * fx))  ystart = int(math.floor((v * d / fy - cube_size / 2.) / d * fy))  yend = int(math.floor((v * d / fy + cube_size / 2.) / d * fy))  # select the cropped domain, if box is beyond the boundary just pad it  cropped = depth[max(ystart, 0):min(yend, depth.shape[0]), max(xstart, 0):min(xend, depth.shape[1])].copy()  cropped = np.pad(cropped, ((abs(ystart)-max(ystart, 0), abs(yend)-min(yend, depth.shape[0])),                                (abs(xstart)-max(xstart, 0), abs(xend)-min(xend, depth.shape[1]))), mode='constant', constant_values=0)  width = cropped.shape[0]  height = cropped.shape[1]  for i in range(width):    for j in range(height):      if(cropped[i][j] == 0):        cropped[i][j] = zend      if(cropped[i][j] < zstart):        cropped[i][j] = zstart      if(cropped[i][j] > zend):        cropped[i][j] = zend  dsize = (img_size, img_size)  wb = (xend - xstart)  hb = (yend - ystart)  # transform 150*150 to 128*128  if wb > hb:    sz = (dsize[0], hb * dsize[0] / wb)  else:    sz = (wb * dsize[1] / hb, dsize[1])  roi = cropped  rz = cv2.resize(cropped, dsize)  ret = np.ones(dsize, np.float32) * zend  # ret = np.ones(dsize, np.float32)  xstart = int(math.floor(dsize[0] / 2 - rz.shape[1] / 2))  xend = int(xstart + rz.shape[1])  ystart = int(math.floor(dsize[1] / 2 - rz.shape[0] / 2))  yend = int(ystart + rz.shape[0])  ret[ystart:yend, xstart:xend] = rz  return retimgDepth = cv2.imread(imgPath+'depth_{}.png'.format(i), -1)colorImg = cv2.imread(imgPath+'color_{}.png'.format(i))# plt.imshow(imgDepth)# get depth in each pixel# plt.show()# print imgDepth.shape# depth = np.asarray(imgDepth[:, :, 0] + imgDepth[:, :, 1] * 256)depth = np.asarray(imgDepth[:, :])depthOrg = depth.copy()# net creation# print depth.shape# print d/10000.0*10d = depthOrg[v, u] + 40# depth = CropImage(depthOrg, [u,v,d], cube_size)depth = CropImage(depthOrg, [u,v,d])# print "%%%%%%%%%%%"# print np.min(depth)# print ddepth = ((depth - d) / (cube_size/2.0)).reshape(img_size, img_size)# depth = ((depth - d) / cube_size).reshape(img_size, img_size)# cv2.circle(depth, (u, v), 3, (0.4, 0, 0.4), thickness=-1)plt.imshow(depth)plt.show()