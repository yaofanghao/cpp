#coding=utf-8import caffeimport numpy as npimport matplotlib.pyplot as pltimport cv2import h5pyimport copydeploy = "deploy.prototxt"caffe_model = "origin.caffemodel"# 1,400,700,900,1100for i in [1,400,700,900,1100]:    h5pyImgSet = "/home/gtayx/caffe/examples/handPoseOriginal/training/h5data/test_normal.h5"    imgSet = h5py.File(h5pyImgSet, 'r')    # groundtruth of joint    joint_h5py = imgSet['joint'][:]    joint_groundtruth = np.zeros(108)    joint_groundtruth = joint_h5py[i,0,0,:]    # print (imgSet.items())    depth = imgSet["depth"][:]    img = np.zeros([128,128])    img1 = np.zeros([128,128])    img = depth[i,0,:,:]    img1 = copy.deepcopy(img)    for m in range(128):        for n in range(128):            if img[m,n]<0:                img[m,n] = 0    img = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB)    joints_filename = "joints.txt"    net = caffe.Net(deploy,caffe_model,caffe.TEST)    transformer = caffe.io.Transformer({'data': net.blobs['data'].data.shape}) #设定图片的shape格式(1,1,128,128)    net.blobs['data'].data[...] = transformer.preprocess('data',img1)      #执行上面设置的图片预处理操作，并将图片载入到blob中    #执行测试    out = net.forward()    joint= net.blobs['DeepHandModelxyz'].data[0].flatten() #取出最后一层（Softmax）属于某个类别的概率值，并打印    print joint    J = 14    joint_id = np.array([0, 3, 6, 9, 12, 15, 18, 21, 24, 25, 27, 30, 31, 32])    joints = np.arange(14)    mat_array = np.ones((128,128), np.float32)    # draw the predicted joints on the img    x = np.zeros(J)    y = np.zeros(J)    z = np.zeros(J)    for j in range(J):        x[j] = joint[joints[j] * 3]        y[j] = joint[joints[j] * 3 + 1]        z[j] = joint[joints[j] * 3 + 2]        cv2.circle(img, (int((x[j] + 1) / 2 * 128), int((- y[j] + 1) / 2 * 128)), 3, (0,0.8,0.8),thickness=-1)    # line 0-3    cv2.line(img,(int((x[0] + 1) / 2 * 128), int((- y[0] + 1) / 2 * 128)),(int((x[1] + 1) / 2 * 128), int((- y[1] + 1) / 2 * 128)), (0,0.8,0.8),1,1,0)    # line 6-9    cv2.line(img,(int((x[2] + 1) / 2 * 128), int((- y[2] + 1) / 2 * 128)),(int((x[3] + 1) / 2 * 128), int((- y[3] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    # line 12-15    cv2.line(img,(int((x[4] + 1) / 2 * 128), int((- y[4] + 1) / 2 * 128)),(int((x[5] + 1) / 2 * 128), int((- y[5] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    # line 18-21    cv2.line(img,(int((x[6] + 1) / 2 * 128), int((- y[6] + 1) / 2 * 128)),(int((x[7] + 1) / 2 * 128), int((- y[7] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    # line 24-25    cv2.line(img,(int((x[8] + 1) / 2 * 128), int((- y[8] + 1) / 2 * 128)),(int((x[9] + 1) / 2 * 128), int((- y[9] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[1] + 1) / 2 * 128), int((- y[1] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[3] + 1) / 2 * 128), int((- y[3] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[5] + 1) / 2 * 128), int((- y[5] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[7] + 1) / 2 * 128), int((- y[7] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[11] + 1) / 2 * 128), int((- y[11] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[12] + 1) / 2 * 128), int((- y[12] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    cv2.line(img,(int((x[10] + 1) / 2 * 128), int((- y[10] + 1) / 2 * 128)),(int((x[9] + 1) / 2 * 128), int((- y[9] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    cv2.line(img,(int((x[10] + 1) / 2 * 128), int((- y[10] + 1) / 2 * 128)),(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)), (0,0.8,0.8), 1,1,0)    # draw the groundtruth on the img    x = np.zeros(J)    y = np.zeros(J)    z = np.zeros(J)    for j in range(J):        x[j] = joint_groundtruth[joints[j] * 3]        y[j] = joint_groundtruth[joints[j] * 3 + 1]        z[j] = joint_groundtruth[joints[j] * 3 + 2]        cv2.circle(img, (int((x[j] + 1) / 2 * 128), int((- y[j] + 1) / 2 * 128)), 3, (0.4,0,0.4),thickness=-1)    # line 0-3    cv2.line(img,(int((x[0] + 1) / 2 * 128), int((- y[0] + 1) / 2 * 128)),(int((x[1] + 1) / 2 * 128), int((- y[1] + 1) / 2 * 128)), (0.4,0,0.4),1,1,0)    # line 6-9    cv2.line(img,(int((x[2] + 1) / 2 * 128), int((- y[2] + 1) / 2 * 128)),(int((x[3] + 1) / 2 * 128), int((- y[3] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    # line 12-15    cv2.line(img,(int((x[4] + 1) / 2 * 128), int((- y[4] + 1) / 2 * 128)),(int((x[5] + 1) / 2 * 128), int((- y[5] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    # line 18-21    cv2.line(img,(int((x[6] + 1) / 2 * 128), int((- y[6] + 1) / 2 * 128)),(int((x[7] + 1) / 2 * 128), int((- y[7] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    # line 24-25    cv2.line(img,(int((x[8] + 1) / 2 * 128), int((- y[8] + 1) / 2 * 128)),(int((x[9] + 1) / 2 * 128), int((- y[9] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[1] + 1) / 2 * 128), int((- y[1] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[3] + 1) / 2 * 128), int((- y[3] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[5] + 1) / 2 * 128), int((- y[5] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[7] + 1) / 2 * 128), int((- y[7] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[11] + 1) / 2 * 128), int((- y[11] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    cv2.line(img,(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)),(int((x[12] + 1) / 2 * 128), int((- y[12] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    cv2.line(img,(int((x[10] + 1) / 2 * 128), int((- y[10] + 1) / 2 * 128)),(int((x[9] + 1) / 2 * 128), int((- y[9] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    cv2.line(img,(int((x[10] + 1) / 2 * 128), int((- y[10] + 1) / 2 * 128)),(int((x[13] + 1) / 2 * 128), int((- y[13] + 1) / 2 * 128)), (0.4,0,0.4), 1,1,0)    plt.figure()    plt.imshow(img, cmap='gray')    plt.show()